(define (get-n args n)
	(if (= n 1)
		(car args)
		(get-n (cdr args) (- n 1))
	)
)

(define (coerce-to args n)
	(let ((target (get-n args n)) (type-target (type-tag (get-n args n))))
		(define (coerce-a-b b)
			(let ((type-b (type-tag b)))
				(cond 
					((eqv? type-target type-b) b)
					((get-coercion typeb type-target) ((get-coercion typeb type-target) (contents b)))
					(else false)
				)
			)
		)
		(filter (lambda (x) x) (map coerce-a-b args))
	)
)

(define (coerce-and-apply args n op)
	(if (> n (length args))
		(error "No method for these args" (list op args))
		(let ((same-type-args (coerce-to args n)))
			(if (not (= (length same-type-args) (length args)))
				(coerce-and-apply args (+ n 1) op)
				(if (get op (map type-tag (coerce-to args n)))
					(apply (get op (map type-tag (coerce-to args n))) (map contents args))
					(coerce-and-apply args (+ n 1) op)
				)
			)
		)
	)
)

(define (apply-generic op . args)
	(let ((type-tags (map type-tag args)))
		(let ((proc (get op type-tags))) 
			(if proc
				(apply proc (map contents args)) 
				(if (> (length args) 1)
					(coerce-and-apply args 1 op)
          (error "No method for these types" (list op type-tags))
        )
      )
    )
  )
)